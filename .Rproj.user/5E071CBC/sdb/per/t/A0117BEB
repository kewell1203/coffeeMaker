{
    "contents" : "likertdist <- function(theta, beta, w = -3:3) {\n  pp <- exp(w * theta + beta)\n  p <- pp / sum(pp)\n  names(p) <- w\n  return(p)\n}\n\nlikert <- function(x, theta, beta, w = -3:3) {\n  xi <- match(x, w)\n  if (any(is.na(xi)))\n    stop(\"Response values do not match response scale.\")\n  likertdist(theta, beta, w)[xi]\n}\n\nlikertexpect <- function(theta, beta, w = -3:3, values = w) {\n  sum(likertdist(theta, beta, w) * values)\n}\n\nlikertmode <- function(theta, beta, w = -3:3, values = w) {\n  w[which.max(likertdist(theta, beta, w))]\n}\n\ndark <- function(col, factor = 0.7) {\n  cc <- rgb2hsv(col2rgb(col))\n  cc[\"v\",] <- cc[\"v\",] * factor\n  h <- t(cc) \n  hsv(h[,\"h\"], h[,\"s\"], h[,\"v\"])\n}\n\ncolorRampHighLow <- function(n) {\n  pal <- colorRampPalette(c(\"#67001F\", \"#B2182B\", \"#D6604D\", \"#F4A582\", \"#FDDBC7\", \n                            \"#FFFFFF\", \"#D1E5F0\", \"#92C5DE\", \"#4393C3\", \"#2166AC\", \"#053061\"))\n  col <- pal(n + 2)[(1:n) + 1]\n  return(col)  \n}\n\nplotlikert <- function(beta, w = -3:3, xlim = c(-3,3), n = 101, col = NULL, type = \"l\", plot.it = TRUE, ...) {\n  theta <- seq(xlim[[1]], xlim[[2]], length.out=n)\n  r <- sapply(theta, function(thetai) likertdist(thetai, beta, w))\n  result <- as.data.frame(t(r))\n  rownames(result) <- theta\n  if (missing(col) || is.null(col))\n    col <- dark(colorRampHighLow(ncol(result)))\n  if (plot.it) {\n    plot(theta, result[[1]], xlim=xlim, ylim=c(0, 1), col=col[[1]], type=type, ylab=\"Probability\", ...)\n    for(i in 2:ncol(result))\n      points(theta, result[[i]], col=col[[i]], type=type, ...)\n    invisible(result)\n  } else \n    return(result)\n}\n\nbarplotlikert <- function(beta, w = -3:3, xlim = c(-3,3), n = 25, col = NULL, plot.it = TRUE, ...) {\n  result <- plotlikert(beta, w, xlim, n, plot.it = F)\n  if (missing(col) || is.null(col)) \n    col <- colorRampHighLow(ncol(result))\n  if (plot.it) {\n    barplot(t(as.matrix(result)), col=col, ...)\n    invisible(result)\n  } else\n    return(result)\n}\n\nlikertbeta <- function(alpha) {\n  -diffinv(c(-rev(alpha), alpha))\n}\n\nlikertlm <- function (formula, data, subset, na.action, \n                      method = c(\"symmetric\", \"full\"), alpha = NULL, beta = NULL,\n                      w = -3:3, model = TRUE, x = FALSE, y = FALSE, contrasts = NULL, \n                      optim.method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\"), \n                      optim.control = list(), optim.start = NULL, ...) {\n  method <- match.arg(method)\n  optim.method <- match.arg(optim.method)\n  ret.x <- x\n  ret.y <- y\n  cl <- match.call()\n  mf <- match.call(expand.dots = FALSE)\n  m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \"offset\"), names(mf), 0L)\n  mf <- mf[c(1L, m)]\n  mf$drop.unused.levels <- TRUE\n  mf[[1L]] <- as.name(\"model.frame\")\n  mf <- eval(mf, parent.frame())\n  if (method == \"model.frame\") \n    return(mf)\n  mt <- attr(mf, \"terms\")\n  y <- model.response(mf, \"numeric\")\n  if (is.matrix(y))\n    stop(\"Only one response variable allowed.\")\n  if (is.empty.model(mt)) {\n    x <- NULL\n    z <- likert.fit(y, method=method, alpha=alpha, beta=beta, w=w, \n                    optim.method=optim.method, optim.control=optim.control, optim.start=optim.start, ...)\n    z$coefficients = numeric()\n  } else {\n    x <- model.matrix(mt, mf, contrasts)\n    z <- likertlm.fit(x, y, method=method, alpha=alpha, beta=beta, w=w, \n                      optim.method=optim.method, optim.control=optim.control, optim.start=optim.start, ...)\n  }\n  class(z) <- \"likertlm\"\n  z$na.action <- attr(mf, \"na.action\")\n  z$contrasts <- attr(x, \"contrasts\")\n  z$xlevels <- .getXlevels(mt, mf)\n  z$call <- cl\n  z$method <- method\n  z$terms <- mt\n  if (model) \n    z$model <- mf\n  if (ret.x) \n    z$x <- x\n  if (ret.y) \n    z$y <- y\n  z$w <- w\n  z\n}\n\nlikertlm.fit <- function(x, y, method = c(\"symmetric\", \"full\"), alpha = NULL, beta = NULL, w = -3:3, \n                         optim.method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\"), \n                         optim.control = list(), optim.start = NULL, ...) {\n  method <- match.arg(method)\n  optim.method <- match.arg(optim.method)\n  if (!is.null(alpha) && method != \"symmetric\")\n    stop(\"A predefined alpha can only be used with method 'symmetric'.\")\n  if (!is.null(beta) && method != \"full\")\n    stop(\"A predefined beta can only be used with method 'full'.\")\n  yi <- match(y, w)\n  if (any(is.na(yi)))\n    stop(\"Response values do not match response scale.\")\n  loglikelihood <- function(coefficients, beta) {\n    theta <- as.vector(x %*% coefficients)\n    v <- cbind(theta, yi)\n    p <- apply(v, 1, function(v) likertdist(v[1], beta, w)[v[2]])\n    sum(-log(p))\n  }\n  nc <- NCOL(x)\n  nb <- length(w)\n  na <- (nb - 1) %/% 2\n  if (method == \"symmetric\" && 2 * na != nb-1)\n    stop(\"Only odd number of levels allowed for 'symmetric' method.\")\n  if (!is.null(alpha) || !is.null(beta)) {\n    if (!is.null(alpha))\n      beta <- likertbeta(alpha)\n    optf <- function(v) {\n      coefficients <- v[1:nc]\n      loglikelihood(coefficients, beta)\n    }\n    if (missing(optim.start) || is.null(optim.start))\n      start <- c(rep(0, nc))\n    else\n      start <- optim.start\n    o <- optim(start, optf, method=optim.method, control=optim.control)\n    coefficients <- o$par[1:nc]\n  } else if (method == \"symmetric\") {\n    optf <- function(v) {\n      coefficients <- v[1:nc]\n      alpha <- v[(nc+1):(nc+na)]\n      beta <- likertbeta(alpha)\n      loglikelihood(coefficients, beta)\n    }\n    if (missing(optim.start) || is.null(optim.start))\n      start <- c(rep(0, nc), rep(1, na))\n    else\n      start <- optim.start\n    o <- optim(start, optf, method=optim.method, control=optim.control)\n    coefficients <- o$par[1:nc]\n    alpha <- o$par[(nc+1):(nc+na)]\n    beta <- likertbeta(alpha)\n  } else {\n    optf <- function(v) {\n      coefficients <- v[1:nc]\n      beta <- c(0, v[(nc+1):(nc+nb-1)])\n      loglikelihood(coefficients, beta)\n    }\n    if (missing(optim.start) || is.null(optim.start))\n      start <- c(rep(0, nc), 1:(nb-1))\n    else\n      start <- optim.start\n    o <- optim(start, optf, method=optim.method, control=optim.control)\n    coefficients <- o$par[1:nc]\n    beta <- c(0, o$par[(nc+1):(nc+nb-1)])\n  }\n  names(coefficients) <- colnames(x)\n  names(beta) <- w\n  if (is.null(alpha))\n    list(coefficients = coefficients, beta = beta, likelihood = o$value)\n  else {\n    names(alpha) <- w[(na+2):nb]  \n    list(coefficients = coefficients, alpha = alpha, beta = beta, likelihood = o$value)\n  }\n}\n\nlikert.fit <- function(y, method = c(\"symmetric\", \"full\"), alpha = NULL, beta = NULL, w = -3:3, \n                       optim.method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\"), \n                       optim.control = list(), optim.start = NULL, ...) {\n  method <- match.arg(method)\n  optim.method <- match.arg(optim.method)\n  if (!is.null(alpha) && method != \"symmetric\")\n    stop(\"A predefined alpha can only be used with method 'symmetric'.\")\n  if (!is.null(beta) && method != \"full\")\n    stop(\"A predefined beta can only be used with method 'full'.\")\n  yi <- match(y, w)\n  if (any(is.na(yi)))\n    stop(\"Response values do not match response scale.\")\n  loglikelihood <- function(beta) {\n    l <- likertdist(0, beta, w)\n    p <- l[yi]\n    sum(-log(p))\n  }\n  nb <- length(w)\n  na <- (nb - 1) %/% 2\n  if (method == \"symmetric\" && 2 * na != nb-1)\n    stop(\"Only odd number of levels allowed for 'symmetric' method.\")\n  if (!is.null(alpha) || !is.null(beta)) {\n    if (!is.null(alpha))\n      beta <- likertbeta(alpha)\n  } else if (method == \"symmetric\") {\n    optf <- function(alpha) {\n      beta <- likertbeta(alpha)\n      loglikelihood(beta)\n    }\n    if (missing(optim.start) || is.null(optim.start))\n      start <- rep(1, na)\n    else\n      start <- optim.start\n    o <- optim(start, optf, method=optim.method, control=optim.control)\n    alpha <- o$par\n    beta <- likertbeta(alpha)\n  } else {\n    optf <- function(v) {\n      beta <- c(0, v)\n      loglikelihood(beta)\n    }\n    if (missing(optim.start) || is.null(optim.start))\n      start <- 1:(nb-1)\n    else\n      start <- optim.start\n    o <- optim(start, optf, method=optim.method, control=optim.control)\n    beta <- c(0, o$par)\n  }\n  names(beta) <- w\n  if (is.null(alpha))\n    list(beta = beta, likelihood = o$value)\n  else {\n    names(alpha) <- w[(na+2):nb]  \n    list(alpha = alpha, beta = beta, likelihood = o$value)\n  }\n}\n\nprint.likertlm <- function(x, digits = max(3, getOption(\"digits\") - 3), ...) {\n  cat(\"\\nCall:\\n\", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \"\\n\\n\", sep = \"\")\n  if (length(coef(x))) {\n    cat(\"Coefficients:\\n\")\n    print.default(format(coef(x), digits = digits), print.gap = 2, quote = FALSE)\n  }\n  else cat(\"No coefficients\\n\")\n  cat(\"\\n\")\n  if (is.null(x$alpha)) {\n    cat(\"beta:\\n\")\n    print.default(format(x$beta, digits = digits), print.gap = 2, quote = FALSE)\n  } else {\n    cat(\"alpha:\\n\")\n    print.default(format(x$alpha, digits = digits), print.gap = 2, quote = FALSE)\n  }\n  cat(\"\\n\")\n  invisible(x)\n}\n\ntheta.likertlm <- function (object, newdata, na.action = na.pass, ...) {\n  tt <- terms(object)\n  if (!inherits(object, \"likertlm\")) \n    warning(\"calling theta.likertlm(<fake-likertlm-object>) ...\")\n  if (missing(newdata) || is.null(newdata)) \n    X <- model.matrix(object$terms, object$model)\n  else {\n    Terms <- delete.response(tt)\n    m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)\n    if (!is.null(cl <- attr(Terms, \"dataClasses\"))) \n      .checkMFClasses(cl, m)\n    X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)\n  }\n  coef <- object$coefficients\n  drop(X %*% coef)\n}\n\nlikertlmdist <- function(object, newdata, na.action = na.pass, ...) {\n  theta <- theta.likertlm(object, newdata, na.action = na.action, ...)\n  t(sapply(theta, function(theta) likertdist(theta, object$beta, object$w)))\n}\n\nlikertlmexpect <- function(object, newdata, na.action = na.pass, values = NULL, ...) {\n  theta <- theta.likertlm(object, newdata, na.action = na.action, ...)\n  if (missing(values) || is.null(values))\n    sapply(theta, function(theta) likertexpect(theta, object$beta, object$w))\n  else\n    sapply(theta, function(theta) likertexpect(theta, object$beta, object$w, values = values))\n}\n\nlikertlmmode <- function(object, newdata, na.action = na.pass, ...) {\n  theta <- theta.likertlm(object, newdata, na.action = na.action, ...)\n  sapply(theta, function(theta) likertmode(theta, object$beta, object$w))\n}\n\nlikertlmprob <- function(object, newdata, na.action = na.pass, ...) {\n  if (missing(newdata) || is.null(newdata)) \n    resp <- model.response(object$model)\n  else\n    resp <- model.response(model.frame(object$terms, newdata, na.action = na.action, xlev = object$xlevels))\n  theta <- theta.likertlm(object, newdata, na.action = na.action)\n  p <- Vectorize(function(x, theta) if (is.na(x)) NA else likert(x, theta, object$beta, object$w))(resp, theta)\n  names(p) <- names(theta)\n  p\n}\n\nlikelihood.likertlm <- function(object, newdata, na.action = na.pass, ...) {\n  p <- likertlmprob(object, newdata, na.action = na.action, ...)\n  -sum(log(p))\n}\n\nsummary.likertlm <- function(object) {\n  z <- object\n  class(z) <- c(\"summary.likertlm\", \"likertlm\")\n  z\n}\n\nprint.summary.likertlm <- function(x, digits = max(3, getOption(\"digits\") - 3), ...) {\n  print.likertlm(x, digits, ...)\n  cat(\"Log-Likelihood: \", format(x$likelihood, digits = digits), \"\\n\")\n  cat(\"\\n\")\n  invisible(x)\n}\n\ncomparelikertlm <- function(object, olddata, newdata, na.action = na.pass, ...) {\n  if (missing(newdata) || is.null(newdata)) {\n    newdata <- as.data.frame(matrix(, 1, 0))\n  }\n  m <- likertlmdist(object, newdata, na.action, ...)\n  if (is.null(rownames(m))) \n    rownames(m) <- if (NROW(m) == 1) \"dist\" else paste0(\"dist\", seq_len(NROW(m)))\n  else\n    rownames(m) <- paste0(\"dist\", rownames(m))\n  if (!missing(olddata) && !is.null(olddata)) {\n    om <- model.frame(object$terms, olddata, na.action = na.action, xlev = object$xlevels)\n    ore <- model.response(om)\n    w <- object$w\n    freq <- sapply(w, function(x) sum(ore == x, na.rm=T))\n    freq <- freq / sum(freq)\n    freq <- matrix(freq, 1, length(w))\n    rownames(freq) <- \"freq\"\n    m <- rbind(m, freq)\n  }\n  m  \n}\n\nbarplotcomparelikertlm <- function(object, olddata, newdata, na.action = na.pass, \n                                   col = c(\"lavender\", \"cornsilk\"), legend = T, ...) {\n  m <- comparelikertlm(object, olddata, newdata, na.action)\n  barplot(m, beside=T, col=col, ...)\n  if (legend) \n    legend(\"topright\", rownames(m), fill=col)\n  invisible(m)\n}\n  \n#####\n\nplotkaffeelikertexpect <- function(x, data = NULL, legend = T, col = NULL, step = 100, ylab = NULL, values = NULL, ...) {\n  require(plyr)\n  if (is.formula(x))\n    object <- likertlm(x, data)\n  else\n    object <- x\n  func <- function(Mehlmenge, Mahlgrad, Nasspressen) \n    likertlmexpect(object, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen), values = values)\n  if (missing(ylab))\n    ylab <- names(object$model)[attr(object$terms, \"response\")]\n  plotkaffeefunc(func, legend=legend, col=col, step=step, ylab=ylab, ...)\n  invisible(object)\n}\n\n##### Beispiel:\n\n# plotkaffeelikertexpect(Geschmack ~ Mehlmenge * Mahlgrad + I(Mehlmenge^2) + Nasspressen, kaffee.main)\n\n##### Beispiel:\n\n# model.Suesse <- likertlm(Suesse ~ Mehlmenge + Mahlgrad + Nasspressen, kaffee.main0)\n# model.Saeure <- likertlm(Saeure ~ Mehlmenge + Mahlgrad + Nasspressen, kaffee.main0)\n# model.Bitterkeit <- likertlm(Bitterkeit ~ Mehlmenge + Mahlgrad + Nasspressen, kaffee.main0)\n# model.Koerper <- likertlm(Koerper ~ Mehlmenge + Mahlgrad + Nasspressen, kaffee.main0)\n# model.Geschmack <- likertlm(Geschmack ~ Mehlmenge + Mahlgrad + Nasspressen, kaffee.main0)\n# \n# kaffeefunc <- function(Mehlmenge, Mahlgrad, Nasspressen) {\n#   values <- c(0, 0, .5, 1, .5, 0, 0)\n#   su <- likertlmexpect(model.Suesse, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen), values = values)  \n#   sa <- likertlmexpect(model.Saeure, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen), values = values)  \n#   bi <- likertlmexpect(model.Bitterkeit, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen), values = values)  \n#   ko <- likertlmexpect(model.Koerper, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen), values = values)  \n#   - log(su) - log(sa) - log(bi) - log(ko)\n# }\n# \n# plotkaffeefunc(kaffeefunc)\n\n##### Beispiel:\n\n# model.Suesse <- likertlm(Suesse ~ Mehlmenge + Mahlgrad + Nasspressen + Wassermenge, kaffee.all0, alpha = c(-.5, 1, 2), optim.method = \"BFGS\")\n# model.Saeure <- likertlm(Saeure ~ Mehlmenge + Mahlgrad + Nasspressen + Wassermenge, kaffee.all0, alpha = c(-.5, 1, 2), optim.method = \"BFGS\")\n# model.Bitterkeit <- likertlm(Bitterkeit ~ Mehlmenge + Mahlgrad + Nasspressen + Wassermenge, kaffee.all0, alpha = c(-.5, 1, 2), optim.method = \"BFGS\")\n# model.Koerper <- likertlm(Koerper ~ Mehlmenge + Mahlgrad + Nasspressen + Wassermenge, kaffee.all0, alpha = c(-.5, 1, 2), optim.method = \"BFGS\")\n# model.Geschmack <- likertlm(Geschmack ~ Mehlmenge + Mahlgrad + Nasspressen + Wassermenge, kaffee.all0, alpha = c(-.5, 1, 2), optim.method = \"BFGS\")\n# \n# kaffeefunc <- function(Mehlmenge, Mahlgrad, Nasspressen, Wassermenge = 25, values = c(0, 0, 0, 1, 0, 0, 0)) {\n#   su <- likertlmexpect(model.Suesse, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen, Wassermenge = Wassermenge), values = values)  \n#   sa <- likertlmexpect(model.Saeure, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen, Wassermenge = Wassermenge), values = values)  \n#   bi <- likertlmexpect(model.Bitterkeit, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen, Wassermenge = Wassermenge), values = values)  \n#   ko <- likertlmexpect(model.Koerper, data.frame(Mehlmenge=Mehlmenge, Mahlgrad=Mahlgrad, Nasspressen=Nasspressen, Wassermenge = Wassermenge), values = values)  \n#   - log(su) - log(sa) - log(bi) - log(ko)\n# }\n# \n# plotkaffeefunc(kaffeefunc)\n",
    "created" : 1357208581583.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2631783268",
    "id" : "A0117BEB",
    "lastKnownWriteTime" : 1357206477,
    "path" : "~/Workspace/SHK@FZI/coffeeMaker/code/likert.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}